Módulos úteis:
    Sytem.Random :cabal install random
    Data.Char 
    Data.List

Métodos de ordenação de listas:
	Insertion Sort 
		Insere recursivamente um elemento no seu respetivo lugar na lista

	Minimum Sort
		Pega no menor elemento da lista recursivamente e adiciona o a uma lista sem esse elemento recursivamente

	Merg Sort
		Divide a lista em 2 recursivamente e no fim junta tudo ordenadamente

	Quick Sort 
		pega num número, e poe para o seu lado esquerdo os números menor que ele e para a direita os numeros maiores que ele, faz isso recursivamente até estár ordenado
		
		é das mais potentes mas funciona "muito mal" se a lista tiver ordenada de forma
		decrescente ou se já tiver ordenada
		
	Bubble Sort
		troca os elementos 2 a dois recursivamente
		se fosse um jogo de cartas seria o peixinho, uma merda


para executar programas seguidos, comandos, IOs, usa-se o: do 

Classes e instâncias 


Árvores binárias
binaias
rose
Nestas árvores a informação está nos nodos (as extermidades da árvore têm apenas
uma marca – Empty). É também habitual definirem-se árvores em que a informação
está apenas nas extermidades (leaf trees):
full trees onde a informação está não só nos nodos, como também nas
folhas


Assinatura de uma função:

função :: Ord a =>
função :: Eq a => ...
	utiliza-se (Ord a) quando se quer comparar com < e > valores a 
	utiliza-se (Eq a)  quando se quer compara com == valores a





Operadores

.
	utiliza se para criar funçoes compostas sem dar argumentos  
	se criarmos uma funçao h que seja: h = f (g x)
	pode-se escrever assim:
	h x = f(g x)
	h x = f $ g x
	h x = (f . g) x
	com o operador . não é necessário usar argumentos:
	h = f . g
	h = f $ g  -> dá erro

	f = (+1) . (*2) 

$
	utiliza se em cadeias de funçoes
	basicamente é para nos livrar-nos dos parentesis 
	length $ take 1 $ drop 3 $ reverse $ [1..10]
	equivalente sem o $ 
	length ( take 1 ( drop 3 ( reverse  [1..10] )))

Funções anónimas:
	são funções que aparecem sem nome, são inciadas com uma \ (utliza-se expressões lamdas)
	\x <- x+1

Funções de ordem superior:
	Funções que aceitam outras como argumento
	listas em compreensão

Cronómetro
:i FIXME
:set +s
	inicia o cronómetro, conta o tempo de cada função executada


Construção de listas:

[n0..n]
	constroi uma lista de n0 até n,   nota funciona com carateres
	['a'..'z'] = "abcdefghijklmnopqrstuvwxyz"
	[1..10] = [1,2,3,4,5,6,7,8,9,10]

[n0,n1..n]
	constroi uma lista até n em que n0 é o primeiro elemento, n1 o segundo, 
	os outros elementos tem sempre uma diferença de n1-n0.
	[0,5..50] = [0,5,10,15,20,25,30,35,40,45,50]
	[50,45..0] = [50,45,40,35,30,25,20,15,10,5,0]

Listas em compreensão

{x | x in N && x < 10} = {1,2,3,4,5,6,7,8,9}
lista em compreensao      lista em extensao 

exemplo 
	[x | x <- [1..10], mod x 2 == 0 ] == [2,4,6,8,10]


funções infixas (operadores "entre" os operandos) +,*,/,!!
	4 + 5,[1,2,3] !! 2
podem ser usadas em modo prefixo, englobando-as em ()
	(+) 4 5, (!!) [1,2,3] 2


funções prefixas(operador aparece "antes dos operandos") div, mod, elem 
	div 46 6, elem 'a' "anatomia"
podem ser usadas em modo infixo englobando-as em ``
	46 `div` 6, 'a' `elem` "anatomia"




 it interpretador FIXME

Funções aplicadas a listas:

flip

spin

foldr f l 

foldl

curry

getChar tipo IO 
getLine
    tipo IO 
	a = getLine 
	Prelude> a
	batatas
	"batatas"

read "12"::Int 

brak c l
	equivalente à função span invocada com a condição negada

span c l
	span é a mesma coisa que (takeWhile c l, dropWhile c l)
	span (<3) [1..10]
	([1,2],[3,4,5,6,7,8,9,10])
	
show x
	transforma tudo em strings
	show 123 = "123"
	show [1..10] = "[1,2,3,4,5,6,7,8,9,10]"
	ghci faz o show em background
	
null l 
	testa se uma lista l é vazia
	null [] = True

concat l
	concatena as lista dentro de uma lista l
 	concat [[],[1],[2..10]] = [1,2,3,4,5,6,7,8,9,10]

cycle l 
	cria uma lista infinita com listas l
	cylcle [1,2,3] = [1,2,3,1,2,3,1,2,3,1,2,3...]

repeat x 
	cria uma lista infinita com os elementos x, pode ser util: take n (repeat 4) 
	repeat 'a' = "aaaaaaaaaaaaaaaaaa..."

replicate n x 
	contrói uma lista com n elementos x
	replicate 5 2 = [2,2,2,2,2]

product [1..n]
	multiplica todos os elementos de uma lista
	product [1,4,5,2] = 40 

unwords l 
	constroi uma string com todos os elementos da lista l (lista de strings) separados por um espaço
	unwords ["o","gandhi","e","fofinho"] = "o gandhi e fofinho"

words l 
	contrário da unwords
	words "o gandhi e fofinho" = ["o","gandhi","e","fofinho"]

putStr x
	imprime uma string x
	putStr "abcd" = abcd

lines l
	controi uma lista com com todos os elementos de uma string separando os por \n
	lines "o\ngandhi\ne\nmuito\nfofinho\n" = ["o","gandhi","e","muito","fofinho"]

unlines l
	contrói uma string com um \n entre cada elemento da lista l,
	é útil quando utilizado com o putStr, assim o \n é interpretado como enter
	unlines ["o","gandhi","e","muito","fofinho"] = "o\ngandhi\ne\nmuito\nfofinho\n" 

splitAt x l
	divide a lista num tuplo x elementos (aproximadamente) cada um 
	splitAt 5 [1,2,3,4,5,6,7,8,9,10] = ([1,2,3,4,5],[6,7,8,9,10]) 

all c l
	testta se um predicado c é verdade para todos os elementos de uma lista l 
	any odd [1..10] == False

any c l 
	testa se um predicado c é verdade para algum elemento de uma lista l 
	any odd [1..10] == True

map x l
	aplica a funçao x a todos os elemtos de lista l 
	map succ [1,2,3,4,5] = [2,3,4,5,6]

filter (x) l
	filtra uma lista por x condição
	filter (< 3) [1,2,3,4,5] = [1,2]

sum l 
	soma todos os valores de uma lista l
	sim [1,2,3,4] == 1

delete x l 
	retira a primeira ocorrência um elemento x de uma lista l
	delete 3 [1,2,3,4,3] = [1,2,4,3]

deleteBy FIXME
 	similar to delete, but it allows the programmers to supply their own equality test 
 	deleteBy (\x y -> mod y x == 0) 4 [6,8,10,12] == []

l !! x
	devolve de uma lista l o elemento que está no índice x 
	[1,2,3,4] !! 3 == 4

insert x l
	inseres o elemento x antes do primeiro elemento que é maior ou igual que x
	insert 4 [1,3,5,7] == [1,3,4,5,7] 

reverse l
	devolve um lista l ao contrário
	reverse [1,2,3,4] == [4,3,2,1]

minimum l 
	devolve o menor elemento de uma lista l 
	minimum [5,8,9,1] == 1

maximum l 
	devolve o maior elemento de uma lista l
	maximum [1,2,3,4] == 4

elemIndices x l
	calcula a lista de posições em que um dado elemento ocorre numa lista
	elemIndices 3 [1,2,3,4,3,2,3,4,5] corresponde a [2,4,6].

dropWhile c l
	faz drop 1 de l até condiçao c falhar
	dropWhile (<5) [1..10] = [5,6,7,8,9,10]
bingo :: IO ()
takeWhile c l 
	faz take da lista l com os elementos até condiçao  falhar
	takeWhile odd [1,3,5,7,9,10,11,13,15,17] = [1,3,5,7,9]

drop n l
	constrói uma lista l sem os n primeiros elementos
	drop 2 [1,2,3,4] == [3,4]

take n l 
	constrói uma lista com os n primeiros elementos de l  
	take  2 [1,2,3,4] == [1,2]

inits l
	constroi uma lista com todos os seguementos iniciais de uma lista
	inits [1,2,3,4] = [[],[1],[1,2],[1,2,3],[1,2,3,4]]


Outros:

FIXME 
signum

id x
	função identidade
	id 5 = 5

sqrt x 
	raiz quadrada de x

abs x
	valor absoluto de x

pred x
	devolve o antecedente de x
	pred 3 = 2

succ x
	devolve o sucessor de um número ou carater 
	succ 5 = 6 

ord x 
	devolve o número do carater x na tabela asci
	ord '0' = 48 

chr x
	devolve o carater com número x na tabela asci
	chr 48 = '0'

digitToInt x
	devolve o inteiro de um carater x
	o mesmo pode ser feito com: ord(x) - 48
	digitToInt '2' = 2

intToDigit x
	devolve o carater de um inteiro x

	intToDigit 2 = '2'

isDigit x
	True se x for um algarismo
	isDigit '3' = True

isAlpha x
	True se x for uma letra
	isDigit 'a' = True

even x
odd x 
	True, verifica se x é par ou ímpar
 
min x y
max x y
	devolvem o mínimo ou máximo entre 2 elementos x,y

div x y
	resto da divisao de x por y 

mod x y 
	divisao por interios

divMod x y 
	devolte um tuplo com o div e mod
	divMod 10 3 == (3,1)


